<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Understanding Structs and Classes in C# | cxyda.github.io</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Understanding Structs and Classes in C#" />
<meta name="author" content="Daniel Steegmüller" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="When diving into the C# multiverse 🌌, we inevitably face the age-old questions about where data lives, how the garbage collector (GC) behaves, and the eternal battle between structs and classes. 🛠️ In this post, we’ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. ⚡" />
<meta property="og:description" content="When diving into the C# multiverse 🌌, we inevitably face the age-old questions about where data lives, how the garbage collector (GC) behaves, and the eternal battle between structs and classes. 🛠️ In this post, we’ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. ⚡" />
<link rel="canonical" href="https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp" />
<meta property="og:url" content="https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp" />
<meta property="og:site_name" content="cxyda.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-11-17T00:00:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Understanding Structs and Classes in C#" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Daniel Steegmüller"},"dateModified":"2024-11-17T21:37:53+05:30","datePublished":"2024-11-17T00:00:00+05:30","description":"When diving into the C# multiverse 🌌, we inevitably face the age-old questions about where data lives, how the garbage collector (GC) behaves, and the eternal battle between structs and classes. 🛠️ In this post, we’ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. ⚡","headline":"Understanding Structs and Classes in C#","mainEntityOfPage":{"@type":"WebPage","@id":"https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp"},"url":"https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="https://cxyda.github.io/feed.xml" title="cxyda.github.io" />

  <!-- Google Analytics-->
  
</head>

  <head>
    <!-- Add the third-party Gist styling library -->
    <link rel="stylesheet" href="assets\css\dark-gist-theme.css">
  </head>
  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">cxyda.github.io</h2>
    </a>
    <ul>
      <li><a href="/">Posts</a></li>
      <li><a href="/tags">Tags</a></li>
      <li><a href="/about">About</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        Daniel Steegmüller
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2024-11-17 00:00:00 +0530">November 17, 2024</time>
      <span> and last updated on&nbsp;</span><time datetime="2024-11-17">November 17, 2024</time>    
    
  </div>

  <h1 class="post-title">Understanding Structs and Classes in C#</h1>
  <div class="post-line"></div>

  <p>When diving into the C# multiverse 🌌, we inevitably face the age-old questions about <strong>where data lives</strong>, <strong>how the garbage collector (GC) behaves</strong>, and <strong>the eternal battle between structs and classes</strong>. 🛠️ In this post, we’ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. ⚡</p>

<hr />

<h3 id="1-are-large-structs-automatically-moved-to-the-heap"><strong>1. Are Large Structs Automatically Moved to the Heap?</strong></h3>

<h4 id="-question">🧠 Question:</h4>
<p>Some claim that structs larger than 16 bytes get auto-promoted to the heap like VIPs at a concert. 🎤 Is this legit? Where do behemoth structs (like a 1 MB struct 🏋️) reside?</p>

<h4 id="-answer">💡 Answer:</h4>
<p>Nope! Large structs don’t magically teleport to the heap unless <strong>explicitly boxed</strong> 🪄 or placed within a reference type (e.g., a class or array). Structs are value types, and their storage location depends on their context:</p>

<ul>
  <li><strong>Local variables</strong>: Stored on the <strong>stack</strong> 🥞, no matter their size.</li>
  <li><strong>Fields of a class</strong>: Stored on the <strong>heap</strong> 🗂️, as part of the class instance.</li>
  <li><strong>Boxed structs</strong>: Stored on the <strong>heap</strong>, wrapped in a shiny object wrapper.</li>
</ul>

<p>⚠️ Beware, adventurer! Using monstrous structs (e.g., 1 MB) on the stack risks summoning the dreaded <code class="language-plaintext highlighter-rouge">StackOverflowException</code> 💀, as the stack has limited space (a few MB per thread). To avoid this peril, Microsoft advises keeping structs compact—preferably under <strong>16–32 bytes</strong>—for smooth sailing. 🚀</p>

<hr />

<h3 id="2-how-does-the-gc-handle-arrays-of-classes-vs-structs"><strong>2. How Does the GC Handle Arrays of Classes vs. Structs?</strong></h3>

<h4 id="-question-1">🤔 Question:</h4>
<p>When the GC visits an array of classes (<code class="language-plaintext highlighter-rouge">CustomClass[]</code>) or structs (<code class="language-plaintext highlighter-rouge">CustomStruct[]</code>), does it handle them differently? Do structs in arrays simply “poof” 💨, or does the GC grind through them one by one?</p>

<h4 id="-answer-1">🔍 Answer:</h4>
<p>Oh, there’s a key difference in how the GC processes arrays of classes and structs:</p>

<ul>
  <li><strong>Array of Classes (<code class="language-plaintext highlighter-rouge">CustomClass[]</code>)</strong>:
    <ul>
      <li>The array itself is a <strong>reference type</strong>, living large on the heap. 🏠</li>
      <li>Each element is a reference (pointer) to a <code class="language-plaintext highlighter-rouge">CustomClass</code> instance, which is also allocated on the heap.</li>
      <li>When the GC runs, it must play detective 🕵️‍♂️, traversing the array and individually releasing each <code class="language-plaintext highlighter-rouge">CustomClass</code> instance if no other references exist. This can be <strong>slow</strong>—think of it as having to clean 1000 rooms in a hotel. 🏨</li>
    </ul>
  </li>
  <li><strong>Array of Structs (<code class="language-plaintext highlighter-rouge">CustomStruct[]</code>)</strong>:
    <ul>
      <li>The array is still a reference type on the heap, but here’s the twist: the structs are stored <strong>inline</strong> in the array’s memory block. 🧱</li>
      <li>When the array is garbage collected, all struct data is wiped out in one fell swoop. 🎯 The GC doesn’t process individual structs, making this approach <strong>leaner and meaner</strong>.</li>
    </ul>
  </li>
</ul>

<p>This structural advantage makes arrays of structs more GC-friendly 🐉, though they can still have trade-offs, like higher copying costs for large structs.</p>

<hr />

<h3 id="3-how-do-readonly-structs-and-the-in-keyword-impact-performance"><strong>3. How Do <code class="language-plaintext highlighter-rouge">readonly</code> Structs and the <code class="language-plaintext highlighter-rouge">in</code> Keyword Impact Performance?</strong></h3>

<h4 id="-question-2">⚡ Question:</h4>
<p>What wizardry happens when you pass a large <code class="language-plaintext highlighter-rouge">readonly</code> struct to a method using the <code class="language-plaintext highlighter-rouge">in</code> keyword? How does this black magic affect memory allocation and performance? 🪄</p>

<h4 id="️-answer">🛠️ Answer:</h4>
<p>The <strong><code class="language-plaintext highlighter-rouge">readonly</code></strong> modifier keeps your struct immutable (think of it as the unshakable Jedi of the struct world 🧘‍♂️), and the <code class="language-plaintext highlighter-rouge">in</code> keyword passes it by reference rather than by value. This combo lets you wield large structs efficiently during method calls without the burden of copying.</p>

<ul>
  <li><strong>Performance Perks</strong>:
    <ul>
      <li>Passing structs with <code class="language-plaintext highlighter-rouge">in</code> eliminates costly copying 🏎️, especially for structs larger than 16 bytes.</li>
      <li>The compiler ensures immutability, so your method can’t modify the struct. This is both safe and elegant—like Gandalf shouting, “You shall not mutate!” 🧙‍♂️</li>
    </ul>
  </li>
  <li><strong>Memory Magic</strong>:
    <ul>
      <li>The struct stays right where it was born (stack or heap), and the method receives a reference. No extra allocations, no fuss. ✨</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-are-arrays-always-stored-on-the-heap-even-when-declared-locally"><strong>4. Are Arrays Always Stored on the Heap, Even When Declared Locally?</strong></h3>

<h4 id="-question-3">🧐 Question:</h4>
<p>If I declare an array locally in a method, does it still chill on the heap? What about its elements? 🗃️</p>

<h4 id="-answer-2">🔑 Answer:</h4>
<p>Yes! Arrays in C# are <strong>always</strong> stored on the heap, regardless of where you declare them. 🏰</p>

<ul>
  <li>The array reference (a pointer) lives on the stack if declared locally, but the array object itself is firmly planted on the heap. 🌱</li>
  <li>For arrays of structs, the struct data is embedded inline within the array block on the heap. For arrays of classes, the array stores references to objects, which are also heap-allocated.</li>
</ul>

<hr />

<h3 id="conclusion-leveling-up-your-struct-and-class-kung-fu-"><strong>Conclusion: Leveling Up Your Struct-and-Class Kung Fu 🥋</strong></h3>

<p>Understanding the subtleties of structs, classes, and GC is essential for mastering C# development. Here’s your TL;DR spellbook 🧙‍♀️:</p>

<ol>
  <li>Large structs don’t magically migrate to the heap but can cause stack troubles if oversized. Keep them small for peak performance. 🏋️‍♀️</li>
  <li>Arrays of structs are <strong>GC-friendly</strong> because the GC doesn’t process each struct individually. 🗑️ Arrays of classes, on the other hand, involve more overhead.</li>
  <li>Use <strong><code class="language-plaintext highlighter-rouge">readonly</code> structs + <code class="language-plaintext highlighter-rouge">in</code></strong> to pass large structs efficiently while preserving immutability. 🏹</li>
  <li>Arrays always hang out on the heap, no matter where they’re declared. 🏠</li>
</ol>

<p>By embracing these principles, you’ll wield the power of C# with the precision of a legendary developer. ⚔️ Your applications will thank you—with fewer bugs and smoother performance! 🚀</p>

<hr />

<h3 id="references-"><strong>References 📚</strong></h3>

<ol>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct">C# Structs</a></li>
  <li>.NET Team Blog: <a href="https://devblogs.microsoft.com/dotnet/">Choosing Between Classes and Structs</a></li>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/">Garbage Collection in .NET</a></li>
  <li>Eric Lippert’s Blog: <a href="https://ericlippert.com/">Value Types and Reference Types</a></li>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier">The <code class="language-plaintext highlighter-rouge">in</code> Parameter Modifier</a></li>
  <li>Performance Tips for Large Structs: <a href="https://learn.microsoft.com/en-us/dotnet/performance/">Benchmarking Structs and Classes</a></li>
  <li>.NET Memory Management Overview: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals">Heap vs. Stack</a></li>
  <li>Stephen Toub’s Blog: <a href="https://devblogs.microsoft.com/dotnet/">Understanding Arrays in .NET</a></li>
</ol>

<p>Got thoughts, questions, or war stories about structs and classes? Drop them in the comments! Let’s geek out together. 🤓</p>

</div>



<div class="pagination">
  
  
    <a href="/UnitysEqualityAndNullPropagationOperators" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>
    </main>

    <footer>
  <span>
    &copy; <time datetime="2024-11-18 02:08:23 +0530">2024</time> Daniel Steegmüller. Made with Jekyll using the <a href="https://github.com/jitinnair1/tail">Tail</a> theme.
  </span>
</footer>


  </body>
</html>
