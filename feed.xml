<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://cxyda.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://cxyda.github.io/" rel="alternate" type="text/html" /><updated>2024-11-18T02:08:26+05:30</updated><id>https://cxyda.github.io/feed.xml</id><title type="html">cxyda.github.io</title><subtitle>A game development blog about c# and Unity3D</subtitle><author><name>Daniel SteegmÃ¼ller</name></author><entry><title type="html">Understanding Structs and Classes in C#</title><link href="https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp" rel="alternate" type="text/html" title="Understanding Structs and Classes in C#" /><published>2024-11-17T00:00:00+05:30</published><updated>2024-11-17T21:37:53+05:30</updated><id>https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp</id><content type="html" xml:base="https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp"><![CDATA[<p>When diving into the C# multiverse ğŸŒŒ, we inevitably face the age-old questions about <strong>where data lives</strong>, <strong>how the garbage collector (GC) behaves</strong>, and <strong>the eternal battle between structs and classes</strong>. ğŸ› ï¸ In this post, weâ€™ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. âš¡</p>

<hr />

<h3 id="1-are-large-structs-automatically-moved-to-the-heap"><strong>1. Are Large Structs Automatically Moved to the Heap?</strong></h3>

<h4 id="-question">ğŸ§  Question:</h4>
<p>Some claim that structs larger than 16 bytes get auto-promoted to the heap like VIPs at a concert. ğŸ¤ Is this legit? Where do behemoth structs (like a 1 MB struct ğŸ‹ï¸) reside?</p>

<h4 id="-answer">ğŸ’¡ Answer:</h4>
<p>Nope! Large structs donâ€™t magically teleport to the heap unless <strong>explicitly boxed</strong> ğŸª„ or placed within a reference type (e.g., a class or array). Structs are value types, and their storage location depends on their context:</p>

<ul>
  <li><strong>Local variables</strong>: Stored on the <strong>stack</strong> ğŸ¥, no matter their size.</li>
  <li><strong>Fields of a class</strong>: Stored on the <strong>heap</strong> ğŸ—‚ï¸, as part of the class instance.</li>
  <li><strong>Boxed structs</strong>: Stored on the <strong>heap</strong>, wrapped in a shiny object wrapper.</li>
</ul>

<p>âš ï¸ Beware, adventurer! Using monstrous structs (e.g., 1 MB) on the stack risks summoning the dreaded <code class="language-plaintext highlighter-rouge">StackOverflowException</code> ğŸ’€, as the stack has limited space (a few MB per thread). To avoid this peril, Microsoft advises keeping structs compactâ€”preferably under <strong>16â€“32 bytes</strong>â€”for smooth sailing. ğŸš€</p>

<hr />

<h3 id="2-how-does-the-gc-handle-arrays-of-classes-vs-structs"><strong>2. How Does the GC Handle Arrays of Classes vs. Structs?</strong></h3>

<h4 id="-question-1">ğŸ¤” Question:</h4>
<p>When the GC visits an array of classes (<code class="language-plaintext highlighter-rouge">CustomClass[]</code>) or structs (<code class="language-plaintext highlighter-rouge">CustomStruct[]</code>), does it handle them differently? Do structs in arrays simply â€œpoofâ€ ğŸ’¨, or does the GC grind through them one by one?</p>

<h4 id="-answer-1">ğŸ” Answer:</h4>
<p>Oh, thereâ€™s a key difference in how the GC processes arrays of classes and structs:</p>

<ul>
  <li><strong>Array of Classes (<code class="language-plaintext highlighter-rouge">CustomClass[]</code>)</strong>:
    <ul>
      <li>The array itself is a <strong>reference type</strong>, living large on the heap. ğŸ </li>
      <li>Each element is a reference (pointer) to a <code class="language-plaintext highlighter-rouge">CustomClass</code> instance, which is also allocated on the heap.</li>
      <li>When the GC runs, it must play detective ğŸ•µï¸â€â™‚ï¸, traversing the array and individually releasing each <code class="language-plaintext highlighter-rouge">CustomClass</code> instance if no other references exist. This can be <strong>slow</strong>â€”think of it as having to clean 1000 rooms in a hotel. ğŸ¨</li>
    </ul>
  </li>
  <li><strong>Array of Structs (<code class="language-plaintext highlighter-rouge">CustomStruct[]</code>)</strong>:
    <ul>
      <li>The array is still a reference type on the heap, but hereâ€™s the twist: the structs are stored <strong>inline</strong> in the arrayâ€™s memory block. ğŸ§±</li>
      <li>When the array is garbage collected, all struct data is wiped out in one fell swoop. ğŸ¯ The GC doesnâ€™t process individual structs, making this approach <strong>leaner and meaner</strong>.</li>
    </ul>
  </li>
</ul>

<p>This structural advantage makes arrays of structs more GC-friendly ğŸ‰, though they can still have trade-offs, like higher copying costs for large structs.</p>

<hr />

<h3 id="3-how-do-readonly-structs-and-the-in-keyword-impact-performance"><strong>3. How Do <code class="language-plaintext highlighter-rouge">readonly</code> Structs and the <code class="language-plaintext highlighter-rouge">in</code> Keyword Impact Performance?</strong></h3>

<h4 id="-question-2">âš¡ Question:</h4>
<p>What wizardry happens when you pass a large <code class="language-plaintext highlighter-rouge">readonly</code> struct to a method using the <code class="language-plaintext highlighter-rouge">in</code> keyword? How does this black magic affect memory allocation and performance? ğŸª„</p>

<h4 id="ï¸-answer">ğŸ› ï¸ Answer:</h4>
<p>The <strong><code class="language-plaintext highlighter-rouge">readonly</code></strong> modifier keeps your struct immutable (think of it as the unshakable Jedi of the struct world ğŸ§˜â€â™‚ï¸), and the <code class="language-plaintext highlighter-rouge">in</code> keyword passes it by reference rather than by value. This combo lets you wield large structs efficiently during method calls without the burden of copying.</p>

<ul>
  <li><strong>Performance Perks</strong>:
    <ul>
      <li>Passing structs with <code class="language-plaintext highlighter-rouge">in</code> eliminates costly copying ğŸï¸, especially for structs larger than 16 bytes.</li>
      <li>The compiler ensures immutability, so your method canâ€™t modify the struct. This is both safe and elegantâ€”like Gandalf shouting, â€œYou shall not mutate!â€ ğŸ§™â€â™‚ï¸</li>
    </ul>
  </li>
  <li><strong>Memory Magic</strong>:
    <ul>
      <li>The struct stays right where it was born (stack or heap), and the method receives a reference. No extra allocations, no fuss. âœ¨</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-are-arrays-always-stored-on-the-heap-even-when-declared-locally"><strong>4. Are Arrays Always Stored on the Heap, Even When Declared Locally?</strong></h3>

<h4 id="-question-3">ğŸ§ Question:</h4>
<p>If I declare an array locally in a method, does it still chill on the heap? What about its elements? ğŸ—ƒï¸</p>

<h4 id="-answer-2">ğŸ”‘ Answer:</h4>
<p>Yes! Arrays in C# are <strong>always</strong> stored on the heap, regardless of where you declare them. ğŸ°</p>

<ul>
  <li>The array reference (a pointer) lives on the stack if declared locally, but the array object itself is firmly planted on the heap. ğŸŒ±</li>
  <li>For arrays of structs, the struct data is embedded inline within the array block on the heap. For arrays of classes, the array stores references to objects, which are also heap-allocated.</li>
</ul>

<hr />

<h3 id="conclusion-leveling-up-your-struct-and-class-kung-fu-"><strong>Conclusion: Leveling Up Your Struct-and-Class Kung Fu ğŸ¥‹</strong></h3>

<p>Understanding the subtleties of structs, classes, and GC is essential for mastering C# development. Hereâ€™s your TL;DR spellbook ğŸ§™â€â™€ï¸:</p>

<ol>
  <li>Large structs donâ€™t magically migrate to the heap but can cause stack troubles if oversized. Keep them small for peak performance. ğŸ‹ï¸â€â™€ï¸</li>
  <li>Arrays of structs are <strong>GC-friendly</strong> because the GC doesnâ€™t process each struct individually. ğŸ—‘ï¸ Arrays of classes, on the other hand, involve more overhead.</li>
  <li>Use <strong><code class="language-plaintext highlighter-rouge">readonly</code> structs + <code class="language-plaintext highlighter-rouge">in</code></strong> to pass large structs efficiently while preserving immutability. ğŸ¹</li>
  <li>Arrays always hang out on the heap, no matter where theyâ€™re declared. ğŸ </li>
</ol>

<p>By embracing these principles, youâ€™ll wield the power of C# with the precision of a legendary developer. âš”ï¸ Your applications will thank youâ€”with fewer bugs and smoother performance! ğŸš€</p>

<hr />

<h3 id="references-"><strong>References ğŸ“š</strong></h3>

<ol>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct">C# Structs</a></li>
  <li>.NET Team Blog: <a href="https://devblogs.microsoft.com/dotnet/">Choosing Between Classes and Structs</a></li>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/">Garbage Collection in .NET</a></li>
  <li>Eric Lippertâ€™s Blog: <a href="https://ericlippert.com/">Value Types and Reference Types</a></li>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier">The <code class="language-plaintext highlighter-rouge">in</code> Parameter Modifier</a></li>
  <li>Performance Tips for Large Structs: <a href="https://learn.microsoft.com/en-us/dotnet/performance/">Benchmarking Structs and Classes</a></li>
  <li>.NET Memory Management Overview: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals">Heap vs. Stack</a></li>
  <li>Stephen Toubâ€™s Blog: <a href="https://devblogs.microsoft.com/dotnet/">Understanding Arrays in .NET</a></li>
</ol>

<p>Got thoughts, questions, or war stories about structs and classes? Drop them in the comments! Letâ€™s geek out together. ğŸ¤“</p>]]></content><author><name>Daniel SteegmÃ¼ller</name></author><category term="C#" /><category term="Unity3D" /><summary type="html"><![CDATA[When diving into the C# multiverse ğŸŒŒ, we inevitably face the age-old questions about where data lives, how the garbage collector (GC) behaves, and the eternal battle between structs and classes. ğŸ› ï¸ In this post, weâ€™ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. âš¡]]></summary></entry><entry><title type="html">Mastering C# Operators in Unity ?., ??, ==</title><link href="https://cxyda.github.io/UnitysEqualityAndNullPropagationOperators" rel="alternate" type="text/html" title="Mastering C# Operators in Unity ?., ??, ==" /><published>2024-11-14T00:00:00+05:30</published><updated>2024-11-17T21:37:53+05:30</updated><id>https://cxyda.github.io/UnitysEqualityAndNullPropagationOperators</id><content type="html" xml:base="https://cxyda.github.io/UnitysEqualityAndNullPropagationOperators"><![CDATA[<p>C# is a powerhouse language âš¡, offering an array of features like <strong>syntactic sugar</strong> and expressive tools that make your code concise, readable, and functional. Among these gems are the <strong><code class="language-plaintext highlighter-rouge">?.</code></strong>, <strong><code class="language-plaintext highlighter-rouge">??</code></strong>, and <strong><code class="language-plaintext highlighter-rouge">==</code></strong> operatorsâ€”designed to handle nullability, default values, and equality with elegance. âœ¨</p>

<p>But hereâ€™s the twist: when Unity enters the chat, things getâ€¦ <em>interesting</em>. ğŸ˜… Unityâ€™s handling of <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> derivatives (GameObjects, MonoBehaviours, ScriptableObjects, etc.) adds unique nuancesâ€”and even potential pitfallsâ€”to these operatorsâ€™ behavior. This post dives into their quirks, benefits, and challenges in Unityâ€™s world. ğŸ› ï¸</p>

<hr />

<h2 id="the--operator-equality-in-c-vs-unity"><strong>The <code class="language-plaintext highlighter-rouge">==</code> Operator: Equality in C# vs. Unity</strong></h2>

<p>In standard C#, the <code class="language-plaintext highlighter-rouge">==</code> operator checks for <strong>value equality</strong> in value types and <strong>reference equality</strong> in reference types. Sounds simple, right? Not so fast! ğŸ›‘ Unity overrides this operator for objects derived from <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>. While this adds developer-friendly â€œquality of lifeâ€ features ğŸ›¡ï¸, it can also lead to surprising results.</p>

<hr />

<h3 id="unitys-take-on-"><strong>Unityâ€™s Take on <code class="language-plaintext highlighter-rouge">==</code></strong></h3>

<p>Letâ€™s unravel the mystery with some code:</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/67224a2fe58e9f387943c50e06a5f9b0.js"> </script>

<p>As the code shows, things getâ€¦ <em>weird</em> in the <code class="language-plaintext highlighter-rouge">Update()</code> method. By overriding the <code class="language-plaintext highlighter-rouge">==</code> operator, Unity shields you from common mistakes. ğŸ™Œ</p>

<p>Hereâ€™s what happens:</p>
<ul>
  <li>At the start of the frame, the object is marked for destruction.</li>
  <li>The underlying C# object isnâ€™t technically <code class="language-plaintext highlighter-rouge">null</code> yetâ€”the garbage collector hasnâ€™t cleaned it up.</li>
  <li>Unity steps in and pretends the object is null when you try to access it, ensuring that your code doesnâ€™t crash.</li>
</ul>

<p>ğŸ’¡ <strong>TL;DR</strong>: Unityâ€™s <code class="language-plaintext highlighter-rouge">==</code> operator checks if the object is accessible rather than strictly null, making life easier for developers. Good job, Unity! ğŸ‘</p>

<p>Butâ€¦ what happens when â€˜newerâ€™ (introduced in 2015) C# features like <code class="language-plaintext highlighter-rouge">?.</code> and <code class="language-plaintext highlighter-rouge">??</code> enter the equation? These operators canâ€™t be overridden, and therein lies the chaos. ğŸŒ€</p>

<hr />

<h2 id="the--operator-null-conditional-access"><strong>The <code class="language-plaintext highlighter-rouge">?.</code> Operator: Null-Conditional Access</strong></h2>

<p>The <code class="language-plaintext highlighter-rouge">?.</code> operator is a C# favorite for null-safe access. It allows you to call methods or properties <strong>only if the left-hand object isnâ€™t null</strong>. Otherwise, it short-circuits and returns <code class="language-plaintext highlighter-rouge">null</code>â€”no exceptions, no drama. ğŸ­</p>

<p>But waitâ€¦ Unity doesnâ€™t play by the same rules here. ğŸ˜¬</p>

<hr />

<h3 id="standard-c-example"><strong>Standard C# Example</strong></h3>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/54fe7a3da4e3d95f301a3fd43f37eb13.js?file=example.cs"> </script>

<p>This operator shines when dealing with nullable or optional objects in vanilla C#. It keeps your code clean and crash-free. ğŸš¿</p>

<hr />

<h3 id="the--operator-in-unity"><strong>The <code class="language-plaintext highlighter-rouge">?.</code> Operator in Unity</strong></h3>

<p>In Unity, the null-conditional operator becomes a little tricky:</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/06591e1418084be30b8356183d0ff571.js?file=example.cs"> </script>

<p>In the <code class="language-plaintext highlighter-rouge">Start()</code> method, everything works fine. Unity is happy, and the <code class="language-plaintext highlighter-rouge">?.</code> operator behaves as expected. But in the <strong><code class="language-plaintext highlighter-rouge">Update()</code> method</strong>, all bets are off. ğŸ²</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/f2ffe42b7ccfe676b508937da7dd91fe.js"> </script>

<ul>
  <li>If the GameObject was destroyed earlier that frame, Unityâ€™s <code class="language-plaintext highlighter-rouge">==</code> operator would have protected you.</li>
  <li>But the <code class="language-plaintext highlighter-rouge">?.</code> operator <strong>doesnâ€™t respect Unityâ€™s lifecycle magic</strong>, leading to a <code class="language-plaintext highlighter-rouge">MissingReferenceException</code>.</li>
</ul>

<p>Unityâ€™s overridden behavior doesnâ€™t extend to operators it canâ€™t control, making <code class="language-plaintext highlighter-rouge">?.</code> risky for <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> derivatives. Proceed with caution! ğŸš§</p>

<hr />

<h2 id="the--operator-null-coalescing-awesomeness"><strong>The <code class="language-plaintext highlighter-rouge">??</code> Operator: Null-Coalescing Awesomeness</strong></h2>

<p>The <code class="language-plaintext highlighter-rouge">??</code> operator is a lifesaver for null-checks. It returns the left-hand operand if itâ€™s not null or the right-hand operand otherwise. <strong>Simple, powerful, and concise.</strong> ğŸ’ª</p>

<hr />

<h3 id="standard-c-example-1"><strong>Standard C# Example</strong></h3>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/9057a8a1b63df416c22979b66d9e21f4.js"> </script>

<p>In pure C#, the <code class="language-plaintext highlighter-rouge">??</code> operator is a great way to handle optional values or provide fallbacks with minimal verbosity.</p>

<hr />

<h3 id="the--operator-in-unity-1"><strong>The <code class="language-plaintext highlighter-rouge">??</code> Operator in Unity</strong></h3>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/924684a6ca1b9c83b9927853506fade6.js"> </script>

<p>Here, the <code class="language-plaintext highlighter-rouge">??</code> operator simplifies fallback logic for Unity objects like scripts, components, or optional references. But it has one major caveat:</p>

<ul>
  <li>Like the <code class="language-plaintext highlighter-rouge">?.</code> operator, the <code class="language-plaintext highlighter-rouge">??</code> operator <strong>doesnâ€™t respect Unityâ€™s lifecycle quirks</strong>.</li>
  <li>While itâ€™s less likely to throw immediate exceptions, it can cause subtle bugs if the object was destroyed but not yet cleaned up by the GC.</li>
</ul>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/5cbd59d2b96861b470200b9f377ef3a9.js"> </script>

<p>This contrived case shows how the <code class="language-plaintext highlighter-rouge">??</code> operator could lead to unexpected behavior when working with Unity objects.</p>

<p>ğŸ’¡ <strong>Pro Tip</strong>: Stick to traditional null-checks (<code class="language-plaintext highlighter-rouge">if</code>-<code class="language-plaintext highlighter-rouge">else</code>) for <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> types to avoid surprises.</p>

<hr />

<h2 id="conclusion-use-with-caution-ï¸"><strong>Conclusion: Use with Caution! âš ï¸</strong></h2>

<p>Operators like <code class="language-plaintext highlighter-rouge">?.</code> and <code class="language-plaintext highlighter-rouge">??</code> are fantastic tools working with regular C# objects, making code cleaner, more concise, and less error-prone. But in Unityâ€™s ecosystem, they can introduce subtle, hard-to-diagnose bugs. ğŸ›</p>

<p>Hereâ€™s the golden rule:</p>
<ul>
  <li><strong>For Unity objects (<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> derivatives)</strong>: Avoid using <code class="language-plaintext highlighter-rouge">?.</code> and <code class="language-plaintext highlighter-rouge">??</code> operators. Unityâ€™s lifecycle quirks mean these operators might not behave as expected, potentially causing runtime issues.</li>
  <li><strong>For plain C# objects</strong>: Go wild! These operators make your code safer and more elegant. ğŸ‰</li>
</ul>

<p>And remember: if youâ€™re working in a team or using external plugins, avoid patterns that rely on these operators for Unity objects. Not everyone will be aware of the caveats, and bugs might creep in like ninjas. ğŸ¤º</p>

<hr />

<h3 id="references-"><strong>References ğŸ“š</strong></h3>

<ol>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/">C# Operators Overview</a></li>
  <li>Rider resharper-unity: <a href="https://github.com/JetBrains/resharper-unity/wiki/Possible-unintended-bypass-of-lifetime-check-of-underlying-Unity-engine-object">Unintended Bypass Of Lifetime</a></li>
  <li>Unity Blog: <a href="https://unity.com/blog/engine-platform/custom-operator-should-we-keep-it">Custom == operator, should we keep it?</a></li>
</ol>

<p>Got war stories or lessons learned about using these operators in Unity? Share them in the commentsâ€”letâ€™s learn and laugh together! ğŸ˜„</p>]]></content><author><name>Daniel SteegmÃ¼ller</name></author><category term="C#" /><category term="Unity3D" /><summary type="html"><![CDATA[C# is a powerhouse language âš¡, offering an array of features like syntactic sugar and expressive tools that make your code concise, readable, and functional. Among these gems are the ?., ??, and == operatorsâ€”designed to handle nullability, default values, and equality with elegance. âœ¨]]></summary></entry></feed>