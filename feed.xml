<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://cxyda.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://cxyda.github.io/" rel="alternate" type="text/html" /><updated>2024-11-18T02:08:26+05:30</updated><id>https://cxyda.github.io/feed.xml</id><title type="html">cxyda.github.io</title><subtitle>A game development blog about c# and Unity3D</subtitle><author><name>Daniel Steegmüller</name></author><entry><title type="html">Understanding Structs and Classes in C#</title><link href="https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp" rel="alternate" type="text/html" title="Understanding Structs and Classes in C#" /><published>2024-11-17T00:00:00+05:30</published><updated>2024-11-17T21:37:53+05:30</updated><id>https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp</id><content type="html" xml:base="https://cxyda.github.io/UnderstandingStructsAndClassesInCSharp"><![CDATA[<p>When diving into the C# multiverse 🌌, we inevitably face the age-old questions about <strong>where data lives</strong>, <strong>how the garbage collector (GC) behaves</strong>, and <strong>the eternal battle between structs and classes</strong>. 🛠️ In this post, we’ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. ⚡</p>

<hr />

<h3 id="1-are-large-structs-automatically-moved-to-the-heap"><strong>1. Are Large Structs Automatically Moved to the Heap?</strong></h3>

<h4 id="-question">🧠 Question:</h4>
<p>Some claim that structs larger than 16 bytes get auto-promoted to the heap like VIPs at a concert. 🎤 Is this legit? Where do behemoth structs (like a 1 MB struct 🏋️) reside?</p>

<h4 id="-answer">💡 Answer:</h4>
<p>Nope! Large structs don’t magically teleport to the heap unless <strong>explicitly boxed</strong> 🪄 or placed within a reference type (e.g., a class or array). Structs are value types, and their storage location depends on their context:</p>

<ul>
  <li><strong>Local variables</strong>: Stored on the <strong>stack</strong> 🥞, no matter their size.</li>
  <li><strong>Fields of a class</strong>: Stored on the <strong>heap</strong> 🗂️, as part of the class instance.</li>
  <li><strong>Boxed structs</strong>: Stored on the <strong>heap</strong>, wrapped in a shiny object wrapper.</li>
</ul>

<p>⚠️ Beware, adventurer! Using monstrous structs (e.g., 1 MB) on the stack risks summoning the dreaded <code class="language-plaintext highlighter-rouge">StackOverflowException</code> 💀, as the stack has limited space (a few MB per thread). To avoid this peril, Microsoft advises keeping structs compact—preferably under <strong>16–32 bytes</strong>—for smooth sailing. 🚀</p>

<hr />

<h3 id="2-how-does-the-gc-handle-arrays-of-classes-vs-structs"><strong>2. How Does the GC Handle Arrays of Classes vs. Structs?</strong></h3>

<h4 id="-question-1">🤔 Question:</h4>
<p>When the GC visits an array of classes (<code class="language-plaintext highlighter-rouge">CustomClass[]</code>) or structs (<code class="language-plaintext highlighter-rouge">CustomStruct[]</code>), does it handle them differently? Do structs in arrays simply “poof” 💨, or does the GC grind through them one by one?</p>

<h4 id="-answer-1">🔍 Answer:</h4>
<p>Oh, there’s a key difference in how the GC processes arrays of classes and structs:</p>

<ul>
  <li><strong>Array of Classes (<code class="language-plaintext highlighter-rouge">CustomClass[]</code>)</strong>:
    <ul>
      <li>The array itself is a <strong>reference type</strong>, living large on the heap. 🏠</li>
      <li>Each element is a reference (pointer) to a <code class="language-plaintext highlighter-rouge">CustomClass</code> instance, which is also allocated on the heap.</li>
      <li>When the GC runs, it must play detective 🕵️‍♂️, traversing the array and individually releasing each <code class="language-plaintext highlighter-rouge">CustomClass</code> instance if no other references exist. This can be <strong>slow</strong>—think of it as having to clean 1000 rooms in a hotel. 🏨</li>
    </ul>
  </li>
  <li><strong>Array of Structs (<code class="language-plaintext highlighter-rouge">CustomStruct[]</code>)</strong>:
    <ul>
      <li>The array is still a reference type on the heap, but here’s the twist: the structs are stored <strong>inline</strong> in the array’s memory block. 🧱</li>
      <li>When the array is garbage collected, all struct data is wiped out in one fell swoop. 🎯 The GC doesn’t process individual structs, making this approach <strong>leaner and meaner</strong>.</li>
    </ul>
  </li>
</ul>

<p>This structural advantage makes arrays of structs more GC-friendly 🐉, though they can still have trade-offs, like higher copying costs for large structs.</p>

<hr />

<h3 id="3-how-do-readonly-structs-and-the-in-keyword-impact-performance"><strong>3. How Do <code class="language-plaintext highlighter-rouge">readonly</code> Structs and the <code class="language-plaintext highlighter-rouge">in</code> Keyword Impact Performance?</strong></h3>

<h4 id="-question-2">⚡ Question:</h4>
<p>What wizardry happens when you pass a large <code class="language-plaintext highlighter-rouge">readonly</code> struct to a method using the <code class="language-plaintext highlighter-rouge">in</code> keyword? How does this black magic affect memory allocation and performance? 🪄</p>

<h4 id="️-answer">🛠️ Answer:</h4>
<p>The <strong><code class="language-plaintext highlighter-rouge">readonly</code></strong> modifier keeps your struct immutable (think of it as the unshakable Jedi of the struct world 🧘‍♂️), and the <code class="language-plaintext highlighter-rouge">in</code> keyword passes it by reference rather than by value. This combo lets you wield large structs efficiently during method calls without the burden of copying.</p>

<ul>
  <li><strong>Performance Perks</strong>:
    <ul>
      <li>Passing structs with <code class="language-plaintext highlighter-rouge">in</code> eliminates costly copying 🏎️, especially for structs larger than 16 bytes.</li>
      <li>The compiler ensures immutability, so your method can’t modify the struct. This is both safe and elegant—like Gandalf shouting, “You shall not mutate!” 🧙‍♂️</li>
    </ul>
  </li>
  <li><strong>Memory Magic</strong>:
    <ul>
      <li>The struct stays right where it was born (stack or heap), and the method receives a reference. No extra allocations, no fuss. ✨</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-are-arrays-always-stored-on-the-heap-even-when-declared-locally"><strong>4. Are Arrays Always Stored on the Heap, Even When Declared Locally?</strong></h3>

<h4 id="-question-3">🧐 Question:</h4>
<p>If I declare an array locally in a method, does it still chill on the heap? What about its elements? 🗃️</p>

<h4 id="-answer-2">🔑 Answer:</h4>
<p>Yes! Arrays in C# are <strong>always</strong> stored on the heap, regardless of where you declare them. 🏰</p>

<ul>
  <li>The array reference (a pointer) lives on the stack if declared locally, but the array object itself is firmly planted on the heap. 🌱</li>
  <li>For arrays of structs, the struct data is embedded inline within the array block on the heap. For arrays of classes, the array stores references to objects, which are also heap-allocated.</li>
</ul>

<hr />

<h3 id="conclusion-leveling-up-your-struct-and-class-kung-fu-"><strong>Conclusion: Leveling Up Your Struct-and-Class Kung Fu 🥋</strong></h3>

<p>Understanding the subtleties of structs, classes, and GC is essential for mastering C# development. Here’s your TL;DR spellbook 🧙‍♀️:</p>

<ol>
  <li>Large structs don’t magically migrate to the heap but can cause stack troubles if oversized. Keep them small for peak performance. 🏋️‍♀️</li>
  <li>Arrays of structs are <strong>GC-friendly</strong> because the GC doesn’t process each struct individually. 🗑️ Arrays of classes, on the other hand, involve more overhead.</li>
  <li>Use <strong><code class="language-plaintext highlighter-rouge">readonly</code> structs + <code class="language-plaintext highlighter-rouge">in</code></strong> to pass large structs efficiently while preserving immutability. 🏹</li>
  <li>Arrays always hang out on the heap, no matter where they’re declared. 🏠</li>
</ol>

<p>By embracing these principles, you’ll wield the power of C# with the precision of a legendary developer. ⚔️ Your applications will thank you—with fewer bugs and smoother performance! 🚀</p>

<hr />

<h3 id="references-"><strong>References 📚</strong></h3>

<ol>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct">C# Structs</a></li>
  <li>.NET Team Blog: <a href="https://devblogs.microsoft.com/dotnet/">Choosing Between Classes and Structs</a></li>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/">Garbage Collection in .NET</a></li>
  <li>Eric Lippert’s Blog: <a href="https://ericlippert.com/">Value Types and Reference Types</a></li>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier">The <code class="language-plaintext highlighter-rouge">in</code> Parameter Modifier</a></li>
  <li>Performance Tips for Large Structs: <a href="https://learn.microsoft.com/en-us/dotnet/performance/">Benchmarking Structs and Classes</a></li>
  <li>.NET Memory Management Overview: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals">Heap vs. Stack</a></li>
  <li>Stephen Toub’s Blog: <a href="https://devblogs.microsoft.com/dotnet/">Understanding Arrays in .NET</a></li>
</ol>

<p>Got thoughts, questions, or war stories about structs and classes? Drop them in the comments! Let’s geek out together. 🤓</p>]]></content><author><name>Daniel Steegmüller</name></author><category term="C#" /><category term="Unity3D" /><summary type="html"><![CDATA[When diving into the C# multiverse 🌌, we inevitably face the age-old questions about where data lives, how the garbage collector (GC) behaves, and the eternal battle between structs and classes. 🛠️ In this post, we’ll tackle these concepts with precision, dispel some myths, and arm you with actionable knowledge to level up your .NET skills. ⚡]]></summary></entry><entry><title type="html">Mastering C# Operators in Unity ?., ??, ==</title><link href="https://cxyda.github.io/UnitysEqualityAndNullPropagationOperators" rel="alternate" type="text/html" title="Mastering C# Operators in Unity ?., ??, ==" /><published>2024-11-14T00:00:00+05:30</published><updated>2024-11-17T21:37:53+05:30</updated><id>https://cxyda.github.io/UnitysEqualityAndNullPropagationOperators</id><content type="html" xml:base="https://cxyda.github.io/UnitysEqualityAndNullPropagationOperators"><![CDATA[<p>C# is a powerhouse language ⚡, offering an array of features like <strong>syntactic sugar</strong> and expressive tools that make your code concise, readable, and functional. Among these gems are the <strong><code class="language-plaintext highlighter-rouge">?.</code></strong>, <strong><code class="language-plaintext highlighter-rouge">??</code></strong>, and <strong><code class="language-plaintext highlighter-rouge">==</code></strong> operators—designed to handle nullability, default values, and equality with elegance. ✨</p>

<p>But here’s the twist: when Unity enters the chat, things get… <em>interesting</em>. 😅 Unity’s handling of <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> derivatives (GameObjects, MonoBehaviours, ScriptableObjects, etc.) adds unique nuances—and even potential pitfalls—to these operators’ behavior. This post dives into their quirks, benefits, and challenges in Unity’s world. 🛠️</p>

<hr />

<h2 id="the--operator-equality-in-c-vs-unity"><strong>The <code class="language-plaintext highlighter-rouge">==</code> Operator: Equality in C# vs. Unity</strong></h2>

<p>In standard C#, the <code class="language-plaintext highlighter-rouge">==</code> operator checks for <strong>value equality</strong> in value types and <strong>reference equality</strong> in reference types. Sounds simple, right? Not so fast! 🛑 Unity overrides this operator for objects derived from <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code>. While this adds developer-friendly “quality of life” features 🛡️, it can also lead to surprising results.</p>

<hr />

<h3 id="unitys-take-on-"><strong>Unity’s Take on <code class="language-plaintext highlighter-rouge">==</code></strong></h3>

<p>Let’s unravel the mystery with some code:</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/67224a2fe58e9f387943c50e06a5f9b0.js"> </script>

<p>As the code shows, things get… <em>weird</em> in the <code class="language-plaintext highlighter-rouge">Update()</code> method. By overriding the <code class="language-plaintext highlighter-rouge">==</code> operator, Unity shields you from common mistakes. 🙌</p>

<p>Here’s what happens:</p>
<ul>
  <li>At the start of the frame, the object is marked for destruction.</li>
  <li>The underlying C# object isn’t technically <code class="language-plaintext highlighter-rouge">null</code> yet—the garbage collector hasn’t cleaned it up.</li>
  <li>Unity steps in and pretends the object is null when you try to access it, ensuring that your code doesn’t crash.</li>
</ul>

<p>💡 <strong>TL;DR</strong>: Unity’s <code class="language-plaintext highlighter-rouge">==</code> operator checks if the object is accessible rather than strictly null, making life easier for developers. Good job, Unity! 👏</p>

<p>But… what happens when ‘newer’ (introduced in 2015) C# features like <code class="language-plaintext highlighter-rouge">?.</code> and <code class="language-plaintext highlighter-rouge">??</code> enter the equation? These operators can’t be overridden, and therein lies the chaos. 🌀</p>

<hr />

<h2 id="the--operator-null-conditional-access"><strong>The <code class="language-plaintext highlighter-rouge">?.</code> Operator: Null-Conditional Access</strong></h2>

<p>The <code class="language-plaintext highlighter-rouge">?.</code> operator is a C# favorite for null-safe access. It allows you to call methods or properties <strong>only if the left-hand object isn’t null</strong>. Otherwise, it short-circuits and returns <code class="language-plaintext highlighter-rouge">null</code>—no exceptions, no drama. 🎭</p>

<p>But wait… Unity doesn’t play by the same rules here. 😬</p>

<hr />

<h3 id="standard-c-example"><strong>Standard C# Example</strong></h3>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/54fe7a3da4e3d95f301a3fd43f37eb13.js?file=example.cs"> </script>

<p>This operator shines when dealing with nullable or optional objects in vanilla C#. It keeps your code clean and crash-free. 🚿</p>

<hr />

<h3 id="the--operator-in-unity"><strong>The <code class="language-plaintext highlighter-rouge">?.</code> Operator in Unity</strong></h3>

<p>In Unity, the null-conditional operator becomes a little tricky:</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/06591e1418084be30b8356183d0ff571.js?file=example.cs"> </script>

<p>In the <code class="language-plaintext highlighter-rouge">Start()</code> method, everything works fine. Unity is happy, and the <code class="language-plaintext highlighter-rouge">?.</code> operator behaves as expected. But in the <strong><code class="language-plaintext highlighter-rouge">Update()</code> method</strong>, all bets are off. 🎲</p>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/f2ffe42b7ccfe676b508937da7dd91fe.js"> </script>

<ul>
  <li>If the GameObject was destroyed earlier that frame, Unity’s <code class="language-plaintext highlighter-rouge">==</code> operator would have protected you.</li>
  <li>But the <code class="language-plaintext highlighter-rouge">?.</code> operator <strong>doesn’t respect Unity’s lifecycle magic</strong>, leading to a <code class="language-plaintext highlighter-rouge">MissingReferenceException</code>.</li>
</ul>

<p>Unity’s overridden behavior doesn’t extend to operators it can’t control, making <code class="language-plaintext highlighter-rouge">?.</code> risky for <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> derivatives. Proceed with caution! 🚧</p>

<hr />

<h2 id="the--operator-null-coalescing-awesomeness"><strong>The <code class="language-plaintext highlighter-rouge">??</code> Operator: Null-Coalescing Awesomeness</strong></h2>

<p>The <code class="language-plaintext highlighter-rouge">??</code> operator is a lifesaver for null-checks. It returns the left-hand operand if it’s not null or the right-hand operand otherwise. <strong>Simple, powerful, and concise.</strong> 💪</p>

<hr />

<h3 id="standard-c-example-1"><strong>Standard C# Example</strong></h3>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/9057a8a1b63df416c22979b66d9e21f4.js"> </script>

<p>In pure C#, the <code class="language-plaintext highlighter-rouge">??</code> operator is a great way to handle optional values or provide fallbacks with minimal verbosity.</p>

<hr />

<h3 id="the--operator-in-unity-1"><strong>The <code class="language-plaintext highlighter-rouge">??</code> Operator in Unity</strong></h3>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/924684a6ca1b9c83b9927853506fade6.js"> </script>

<p>Here, the <code class="language-plaintext highlighter-rouge">??</code> operator simplifies fallback logic for Unity objects like scripts, components, or optional references. But it has one major caveat:</p>

<ul>
  <li>Like the <code class="language-plaintext highlighter-rouge">?.</code> operator, the <code class="language-plaintext highlighter-rouge">??</code> operator <strong>doesn’t respect Unity’s lifecycle quirks</strong>.</li>
  <li>While it’s less likely to throw immediate exceptions, it can cause subtle bugs if the object was destroyed but not yet cleaned up by the GC.</li>
</ul>

<noscript><pre>400: Invalid request</pre></noscript>
<script src="https://gist.github.com/5cbd59d2b96861b470200b9f377ef3a9.js"> </script>

<p>This contrived case shows how the <code class="language-plaintext highlighter-rouge">??</code> operator could lead to unexpected behavior when working with Unity objects.</p>

<p>💡 <strong>Pro Tip</strong>: Stick to traditional null-checks (<code class="language-plaintext highlighter-rouge">if</code>-<code class="language-plaintext highlighter-rouge">else</code>) for <code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> types to avoid surprises.</p>

<hr />

<h2 id="conclusion-use-with-caution-️"><strong>Conclusion: Use with Caution! ⚠️</strong></h2>

<p>Operators like <code class="language-plaintext highlighter-rouge">?.</code> and <code class="language-plaintext highlighter-rouge">??</code> are fantastic tools working with regular C# objects, making code cleaner, more concise, and less error-prone. But in Unity’s ecosystem, they can introduce subtle, hard-to-diagnose bugs. 🐛</p>

<p>Here’s the golden rule:</p>
<ul>
  <li><strong>For Unity objects (<code class="language-plaintext highlighter-rouge">UnityEngine.Object</code> derivatives)</strong>: Avoid using <code class="language-plaintext highlighter-rouge">?.</code> and <code class="language-plaintext highlighter-rouge">??</code> operators. Unity’s lifecycle quirks mean these operators might not behave as expected, potentially causing runtime issues.</li>
  <li><strong>For plain C# objects</strong>: Go wild! These operators make your code safer and more elegant. 🎉</li>
</ul>

<p>And remember: if you’re working in a team or using external plugins, avoid patterns that rely on these operators for Unity objects. Not everyone will be aware of the caveats, and bugs might creep in like ninjas. 🤺</p>

<hr />

<h3 id="references-"><strong>References 📚</strong></h3>

<ol>
  <li>Microsoft Learn: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/">C# Operators Overview</a></li>
  <li>Rider resharper-unity: <a href="https://github.com/JetBrains/resharper-unity/wiki/Possible-unintended-bypass-of-lifetime-check-of-underlying-Unity-engine-object">Unintended Bypass Of Lifetime</a></li>
  <li>Unity Blog: <a href="https://unity.com/blog/engine-platform/custom-operator-should-we-keep-it">Custom == operator, should we keep it?</a></li>
</ol>

<p>Got war stories or lessons learned about using these operators in Unity? Share them in the comments—let’s learn and laugh together! 😄</p>]]></content><author><name>Daniel Steegmüller</name></author><category term="C#" /><category term="Unity3D" /><summary type="html"><![CDATA[C# is a powerhouse language ⚡, offering an array of features like syntactic sugar and expressive tools that make your code concise, readable, and functional. Among these gems are the ?., ??, and == operators—designed to handle nullability, default values, and equality with elegance. ✨]]></summary></entry></feed>